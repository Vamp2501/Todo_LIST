import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import React, { memo, useCallback, useState, useEffect, useRef } from 'react';
import PropTypes from 'prop-types';
import { Transition } from 'react-transition-group';
import { StackingOrder, Position } from '../../constants';
import { useMergedRef, usePrevious } from '../../hooks';
import { Portal } from '../../portal';
import { Stack } from '../../stack';
import getPosition from './getPosition';
var animationEasing = {
  spring: 'cubic-bezier(0.175, 0.885, 0.320, 1.175)'
};

var getCSS = function getCSS(_ref) {
  var animationDuration = _ref.animationDuration,
      initialScale = _ref.initialScale;
  return {
    position: 'fixed',
    opacity: 0,
    transitionTimingFunction: animationEasing.spring,
    transitionDuration: "".concat(animationDuration, "ms"),
    transitionProperty: 'opacity, transform',
    transform: "scale(".concat(initialScale, ") translateY(-1px)"),
    '&[data-state="entering"], &[data-state="entered"]': {
      opacity: 1,
      visibility: 'visible',
      transform: 'scale(1)'
    },
    '&[data-state="exiting"]': {
      opacity: 0,
      transform: 'scale(1)'
    }
  };
};

var noop = function noop() {};

var initialDimensions = {
  left: 0,
  top: 0,
  height: 0,
  width: 0,
  transformOrigin: null
};
var Positioner = /*#__PURE__*/memo(function Positioner(props) {
  var target = props.target,
      isShown = props.isShown,
      children = props.children,
      _props$initialScale = props.initialScale,
      initialScale = _props$initialScale === void 0 ? 0.9 : _props$initialScale,
      _props$animationDurat = props.animationDuration,
      animationDuration = _props$animationDurat === void 0 ? 300 : _props$animationDurat,
      _props$position = props.position,
      position = _props$position === void 0 ? Position.BOTTOM : _props$position,
      _props$bodyOffset = props.bodyOffset,
      bodyOffset = _props$bodyOffset === void 0 ? 6 : _props$bodyOffset,
      _props$targetOffset = props.targetOffset,
      targetOffset = _props$targetOffset === void 0 ? 6 : _props$targetOffset,
      _props$onOpenComplete = props.onOpenComplete,
      onOpenComplete = _props$onOpenComplete === void 0 ? noop : _props$onOpenComplete,
      _props$onCloseComplet = props.onCloseComplete,
      onCloseComplete = _props$onCloseComplet === void 0 ? noop : _props$onCloseComplet;

  var _useState = useState(initialDimensions),
      _useState2 = _slicedToArray(_useState, 2),
      dimensions = _useState2[0],
      setDimensions = _useState2[1];

  var previousDimensions = usePrevious(dimensions, initialDimensions);
  var latestAnimationFrame = useRef();
  var transitionState = useRef();
  var positionerRef = useRef();
  var targetRef = useRef();
  var setTargetRef = useMergedRef(targetRef);
  var getRef = useMergedRef(positionerRef);
  var update = useCallback(function () {
    var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!isShown || !targetRef.current || !positionerRef.current) return;
    var targetRect = targetRef.current.getBoundingClientRect();
    var hasEntered = positionerRef.current.getAttribute('data-state') === 'entered';
    var viewportHeight = document.documentElement.clientHeight;
    var viewportWidth = document.documentElement.clientWidth;
    var height;
    var width;

    if (hasEntered) {
      // Only when the animation is done should we opt-in to `getBoundingClientRect`
      var positionerRect = positionerRef.current.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255
      // We need to ceil the width and height to prevent jitter when
      // the window is zoomed (when `window.devicePixelRatio` is not an integer)

      height = Math.round(positionerRect.height);
      width = Math.round(positionerRect.width);
    } else {
      // When the animation is in flight use `offsetWidth/Height` which
      // does not calculate the `transform` property as part of its result.
      // There is still change on jitter during the animation (although unoticable)
      // When the browser is zoomed in â€” we fix this with `Math.max`.
      height = Math.max(positionerRef.current.offsetHeight, prevHeight);
      width = Math.max(positionerRef.current.offsetWidth, prevWidth);
    }

    var _getPosition = getPosition({
      position: position,
      targetRect: targetRect,
      targetOffset: targetOffset,
      dimensions: {
        height: height,
        width: width
      },
      viewport: {
        width: viewportWidth,
        height: viewportHeight
      },
      viewportOffset: bodyOffset
    }),
        rect = _getPosition.rect,
        transformOrigin = _getPosition.transformOrigin;

    setDimensions({
      left: rect.left,
      top: rect.top,
      height: height,
      width: width,
      transformOrigin: transformOrigin
    });
  }, [bodyOffset, isShown, position, targetOffset]); // Call `update` whenever the component has "entered" and dimensions change

  useEffect(function () {
    if (transitionState.current === 'entered') {
      latestAnimationFrame.current = requestAnimationFrame(function () {
        update(previousDimensions.height, previousDimensions.width);
      });
    }

    return function () {
      if (latestAnimationFrame.current) {
        cancelAnimationFrame(latestAnimationFrame.current);
      }
    };
  }, [previousDimensions.height, previousDimensions.width, update]);

  var handleEnter = function handleEnter() {
    transitionState.current = 'entered';
    update();
  };

  var handleExited = function handleExited() {
    transitionState.current = 'exited';
    setDimensions(initialDimensions);
    onCloseComplete();
  };

  return /*#__PURE__*/React.createElement(Stack, {
    value: StackingOrder.POSITIONER
  }, function (zIndex) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, target({
      getRef: setTargetRef,
      isShown: isShown
    }), /*#__PURE__*/React.createElement(Transition, {
      nodeRef: positionerRef,
      appear: true,
      "in": isShown,
      timeout: animationDuration,
      onEnter: handleEnter,
      onEntered: onOpenComplete,
      onExited: handleExited,
      unmountOnExit: true
    }, function (state) {
      return /*#__PURE__*/React.createElement(Portal, null, children({
        top: dimensions.top,
        left: dimensions.left,
        state: state,
        zIndex: zIndex,
        css: getCSS({
          initialScale: initialScale,
          animationDuration: animationDuration
        }),
        style: {
          transformOrigin: dimensions.transformOrigin,
          left: dimensions.left,
          top: dimensions.top,
          zIndex: zIndex
        },
        getRef: getRef,
        animationDuration: animationDuration
      }));
    }));
  });
});
Positioner.propTypes = {
  /**
   * The position the element that is being positioned is on.
   * Smart positioning might override this.
   */
  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),

  /**
   * When true, show the element being positioned.
   */
  isShown: PropTypes.bool,

  /**
   * Function that returns the element being positioned.
   */
  children: PropTypes.func.isRequired,

  /**
   * The minimum distance from the body to the element being positioned.
   */
  bodyOffset: PropTypes.number,

  /**
   * The minimum distance from the target to the element being positioned.
   */
  targetOffset: PropTypes.number,

  /**
   * Function that should return a node for the target.
   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node
   */
  target: PropTypes.func.isRequired,

  /**
   * Initial scale of the element being positioned.
   */
  initialScale: PropTypes.number,

  /**
   * Duration of the animation.
   */
  animationDuration: PropTypes.number,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: PropTypes.func,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: PropTypes.func
};
export default Positioner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9Qb3NpdGlvbmVyLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwibWVtbyIsInVzZUNhbGxiYWNrIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJQcm9wVHlwZXMiLCJUcmFuc2l0aW9uIiwiU3RhY2tpbmdPcmRlciIsIlBvc2l0aW9uIiwidXNlTWVyZ2VkUmVmIiwidXNlUHJldmlvdXMiLCJQb3J0YWwiLCJTdGFjayIsImdldFBvc2l0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwic3ByaW5nIiwiZ2V0Q1NTIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJpbml0aWFsU2NhbGUiLCJwb3NpdGlvbiIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJ0cmFuc2Zvcm0iLCJ2aXNpYmlsaXR5Iiwibm9vcCIsImluaXRpYWxEaW1lbnNpb25zIiwibGVmdCIsInRvcCIsImhlaWdodCIsIndpZHRoIiwidHJhbnNmb3JtT3JpZ2luIiwiUG9zaXRpb25lciIsInByb3BzIiwidGFyZ2V0IiwiaXNTaG93biIsImNoaWxkcmVuIiwiQk9UVE9NIiwiYm9keU9mZnNldCIsInRhcmdldE9mZnNldCIsIm9uT3BlbkNvbXBsZXRlIiwib25DbG9zZUNvbXBsZXRlIiwiZGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJwcmV2aW91c0RpbWVuc2lvbnMiLCJsYXRlc3RBbmltYXRpb25GcmFtZSIsInRyYW5zaXRpb25TdGF0ZSIsInBvc2l0aW9uZXJSZWYiLCJ0YXJnZXRSZWYiLCJzZXRUYXJnZXRSZWYiLCJnZXRSZWYiLCJ1cGRhdGUiLCJwcmV2SGVpZ2h0IiwicHJldldpZHRoIiwiY3VycmVudCIsInRhcmdldFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoYXNFbnRlcmVkIiwiZ2V0QXR0cmlidXRlIiwidmlld3BvcnRIZWlnaHQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsInZpZXdwb3J0V2lkdGgiLCJjbGllbnRXaWR0aCIsInBvc2l0aW9uZXJSZWN0IiwiTWF0aCIsInJvdW5kIiwibWF4Iiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJ2aWV3cG9ydCIsInZpZXdwb3J0T2Zmc2V0IiwicmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlRW50ZXIiLCJoYW5kbGVFeGl0ZWQiLCJQT1NJVElPTkVSIiwiekluZGV4Iiwic3RhdGUiLCJjc3MiLCJzdHlsZSIsInByb3BUeXBlcyIsIm9uZU9mIiwiVE9QIiwiVE9QX0xFRlQiLCJUT1BfUklHSFQiLCJCT1RUT01fTEVGVCIsIkJPVFRPTV9SSUdIVCIsIkxFRlQiLCJSSUdIVCIsImJvb2wiLCJmdW5jIiwiaXNSZXF1aXJlZCIsIm51bWJlciJdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLElBQWhCLEVBQXNCQyxXQUF0QixFQUFtQ0MsUUFBbkMsRUFBNkNDLFNBQTdDLEVBQXdEQyxNQUF4RCxRQUFzRSxPQUF0RTtBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxTQUFTQyxVQUFULFFBQTJCLHdCQUEzQjtBQUNBLFNBQVNDLGFBQVQsRUFBd0JDLFFBQXhCLFFBQXdDLGlCQUF4QztBQUNBLFNBQVNDLFlBQVQsRUFBdUJDLFdBQXZCLFFBQTBDLGFBQTFDO0FBQ0EsU0FBU0MsTUFBVCxRQUF1QixjQUF2QjtBQUNBLFNBQVNDLEtBQVQsUUFBc0IsYUFBdEI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLGVBQXhCO0FBRUEsSUFBTUMsZUFBZSxHQUFHO0FBQ3RCQyxFQUFBQSxNQUFNLEVBQUU7QUFEYyxDQUF4Qjs7QUFJQSxJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBUztBQUFBLE1BQUdDLGlCQUFILFFBQUdBLGlCQUFIO0FBQUEsTUFBc0JDLFlBQXRCLFFBQXNC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QjtBQUNGO0FBQ0E7QUFDRXhELEVBQUFBLFVBQVUsRUFBRWxDLFNBQVMsQ0FBQzJGLE1BN0JEOztBQStCckI7QUFDRjtBQUNBO0FBQ0V4RCxFQUFBQSxZQUFZLEVBQUVuQyxTQUFTLENBQUMyRixNQWxDSDs7QUFvQ3JCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U3RCxFQUFBQSxNQUFNLEVBQUU5QixTQUFTLENBQUN5RixJQUFWLENBQWVDLFVBeENGOztBQTBDckI7QUFDRjtBQUNBO0FBQ0U3RSxFQUFBQSxZQUFZLEVBQUViLFNBQVMsQ0FBQzJGLE1BN0NIOztBQStDckI7QUFDRjtBQUNBO0FBQ0UvRSxFQUFBQSxpQkFBaUIsRUFBRVosU0FBUyxDQUFDMkYsTUFsRFI7O0FBb0RyQjtBQUNGO0FBQ0E7QUFDRXRELEVBQUFBLGVBQWUsRUFBRXJDLFNBQVMsQ0FBQ3lGLElBdkROOztBQXlEckI7QUFDRjtBQUNBO0FBQ0VyRCxFQUFBQSxjQUFjLEVBQUVwQyxTQUFTLENBQUN5RjtBQTVETCxDQUF2QjtBQStEQSxlQUFlN0QsVUFBZiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBtZW1vLCB1c2VDYWxsYmFjaywgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCdcbmltcG9ydCB7IFN0YWNraW5nT3JkZXIsIFBvc2l0aW9uIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmLCB1c2VQcmV2aW91cyB9IGZyb20gJy4uLy4uL2hvb2tzJ1xuaW1wb3J0IHsgUG9ydGFsIH0gZnJvbSAnLi4vLi4vcG9ydGFsJ1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICcuLi8uLi9zdGFjaydcbmltcG9ydCBnZXRQb3NpdGlvbiBmcm9tICcuL2dldFBvc2l0aW9uJ1xuXG5jb25zdCBhbmltYXRpb25FYXNpbmcgPSB7XG4gIHNwcmluZzogJ2N1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIwLCAxLjE3NSknXG59XG5cbmNvbnN0IGdldENTUyA9ICh7IGFuaW1hdGlvbkR1cmF0aW9uLCBpbml0aWFsU2NhbGUgfSkgPT4gKHtcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIG9wYWNpdHk6IDAsXG4gIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogYW5pbWF0aW9uRWFzaW5nLnNwcmluZyxcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHthbmltYXRpb25EdXJhdGlvbn1tc2AsXG4gIHRyYW5zaXRpb25Qcm9wZXJ0eTogJ29wYWNpdHksIHRyYW5zZm9ybScsXG4gIHRyYW5zZm9ybTogYHNjYWxlKCR7aW5pdGlhbFNjYWxlfSkgdHJhbnNsYXRlWSgtMXB4KWAsXG4gICcmW2RhdGEtc3RhdGU9XCJlbnRlcmluZ1wiXSwgJltkYXRhLXN0YXRlPVwiZW50ZXJlZFwiXSc6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJyxcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKSdcbiAgfSxcbiAgJyZbZGF0YS1zdGF0ZT1cImV4aXRpbmdcIl0nOiB7XG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKSdcbiAgfVxufSlcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5jb25zdCBpbml0aWFsRGltZW5zaW9ucyA9IHtcbiAgbGVmdDogMCxcbiAgdG9wOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHdpZHRoOiAwLFxuICB0cmFuc2Zvcm1PcmlnaW46IG51bGxcbn1cblxuY29uc3QgUG9zaXRpb25lciA9IG1lbW8oZnVuY3Rpb24gUG9zaXRpb25lcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0LFxuICAgIGlzU2hvd24sXG4gICAgY2hpbGRyZW4sXG4gICAgaW5pdGlhbFNjYWxlID0gMC45LFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gMzAwLFxuICAgIHBvc2l0aW9uID0gUG9zaXRpb24uQk9UVE9NLFxuICAgIGJvZHlPZmZzZXQgPSA2LFxuICAgIHRhcmdldE9mZnNldCA9IDYsXG4gICAgb25PcGVuQ29tcGxldGUgPSBub29wLFxuICAgIG9uQ2xvc2VDb21wbGV0ZSA9IG5vb3BcbiAgfSA9IHByb3BzXG5cbiAgY29uc3QgW2RpbWVuc2lvbnMsIHNldERpbWVuc2lvbnNdID0gdXNlU3RhdGUoaW5pdGlhbERpbWVuc2lvbnMpXG4gIGNvbnN0IHByZXZpb3VzRGltZW5zaW9ucyA9IHVzZVByZXZpb3VzKGRpbWVuc2lvbnMsIGluaXRpYWxEaW1lbnNpb25zKVxuICBjb25zdCBsYXRlc3RBbmltYXRpb25GcmFtZSA9IHVzZVJlZigpXG4gIGNvbnN0IHRyYW5zaXRpb25TdGF0ZSA9IHVzZVJlZigpXG4gIGNvbnN0IHBvc2l0aW9uZXJSZWYgPSB1c2VSZWYoKVxuICBjb25zdCB0YXJnZXRSZWYgPSB1c2VSZWYoKVxuICBjb25zdCBzZXRUYXJnZXRSZWYgPSB1c2VNZXJnZWRSZWYodGFyZ2V0UmVmKVxuICBjb25zdCBnZXRSZWYgPSB1c2VNZXJnZWRSZWYocG9zaXRpb25lclJlZilcblxuICBjb25zdCB1cGRhdGUgPSB1c2VDYWxsYmFjayhcbiAgICAocHJldkhlaWdodCA9IDAsIHByZXZXaWR0aCA9IDApID0+IHtcbiAgICAgIGlmICghaXNTaG93biB8fCAhdGFyZ2V0UmVmLmN1cnJlbnQgfHwgIXBvc2l0aW9uZXJSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0YXJnZXRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICBjb25zdCBoYXNFbnRlcmVkID0gcG9zaXRpb25lclJlZi5jdXJyZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScpID09PSAnZW50ZXJlZCdcblxuICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICBjb25zdCB2aWV3cG9ydFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG5cbiAgICAgIGxldCBoZWlnaHRcbiAgICAgIGxldCB3aWR0aFxuICAgICAgaWYgKGhhc0VudGVyZWQpIHtcbiAgICAgICAgLy8gT25seSB3aGVuIHRoZSBhbmltYXRpb24gaXMgZG9uZSBzaG91bGQgd2Ugb3B0LWluIHRvIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uZXJSZWN0ID0gcG9zaXRpb25lclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9ldmVyZ3JlZW4vaXNzdWVzLzI1NVxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNlaWwgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdG8gcHJldmVudCBqaXR0ZXIgd2hlblxuICAgICAgICAvLyB0aGUgd2luZG93IGlzIHpvb21lZCAod2hlbiBgd2luZG93LmRldmljZVBpeGVsUmF0aW9gIGlzIG5vdCBhbiBpbnRlZ2VyKVxuICAgICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uZXJSZWN0LmhlaWdodClcbiAgICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHBvc2l0aW9uZXJSZWN0LndpZHRoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgYW5pbWF0aW9uIGlzIGluIGZsaWdodCB1c2UgYG9mZnNldFdpZHRoL0hlaWdodGAgd2hpY2hcbiAgICAgICAgLy8gZG9lcyBub3QgY2FsY3VsYXRlIHRoZSBgdHJhbnNmb3JtYCBwcm9wZXJ0eSBhcyBwYXJ0IG9mIGl0cyByZXN1bHQuXG4gICAgICAgIC8vIFRoZXJlIGlzIHN0aWxsIGNoYW5nZSBvbiBqaXR0ZXIgZHVyaW5nIHRoZSBhbmltYXRpb24gKGFsdGhvdWdoIHVub3RpY2FibGUpXG4gICAgICAgIC8vIFdoZW4gdGhlIGJyb3dzZXIgaXMgem9vbWVkIGluIOKAlCB3ZSBmaXggdGhpcyB3aXRoIGBNYXRoLm1heGAuXG4gICAgICAgIGhlaWdodCA9IE1hdGgubWF4KHBvc2l0aW9uZXJSZWYuY3VycmVudC5vZmZzZXRIZWlnaHQsIHByZXZIZWlnaHQpXG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgocG9zaXRpb25lclJlZi5jdXJyZW50Lm9mZnNldFdpZHRoLCBwcmV2V2lkdGgpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgcmVjdCwgdHJhbnNmb3JtT3JpZ2luIH0gPSBnZXRQb3NpdGlvbih7XG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICB0YXJnZXRPZmZzZXQsXG4gICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgd2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICB3aWR0aDogdmlld3BvcnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0SGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdwb3J0T2Zmc2V0OiBib2R5T2Zmc2V0XG4gICAgICB9KVxuXG4gICAgICBzZXREaW1lbnNpb25zKHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW5cbiAgICAgIH0pXG4gICAgfSxcbiAgICBbYm9keU9mZnNldCwgaXNTaG93biwgcG9zaXRpb24sIHRhcmdldE9mZnNldF1cbiAgKVxuXG4gIC8vIENhbGwgYHVwZGF0ZWAgd2hlbmV2ZXIgdGhlIGNvbXBvbmVudCBoYXMgXCJlbnRlcmVkXCIgYW5kIGRpbWVuc2lvbnMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb25TdGF0ZS5jdXJyZW50ID09PSAnZW50ZXJlZCcpIHtcbiAgICAgIGxhdGVzdEFuaW1hdGlvbkZyYW1lLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB1cGRhdGUocHJldmlvdXNEaW1lbnNpb25zLmhlaWdodCwgcHJldmlvdXNEaW1lbnNpb25zLndpZHRoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGxhdGVzdEFuaW1hdGlvbkZyYW1lLmN1cnJlbnQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUobGF0ZXN0QW5pbWF0aW9uRnJhbWUuY3VycmVudClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtwcmV2aW91c0RpbWVuc2lvbnMuaGVpZ2h0LCBwcmV2aW91c0RpbWVuc2lvbnMud2lkdGgsIHVwZGF0ZV0pXG5cbiAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB7XG4gICAgdHJhbnNpdGlvblN0YXRlLmN1cnJlbnQgPSAnZW50ZXJlZCdcbiAgICB1cGRhdGUoKVxuICB9XG5cbiAgY29uc3QgaGFuZGxlRXhpdGVkID0gKCkgPT4ge1xuICAgIHRyYW5zaXRpb25TdGF0ZS5jdXJyZW50ID0gJ2V4aXRlZCdcbiAgICBzZXREaW1lbnNpb25zKGluaXRpYWxEaW1lbnNpb25zKVxuICAgIG9uQ2xvc2VDb21wbGV0ZSgpXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxTdGFjayB2YWx1ZT17U3RhY2tpbmdPcmRlci5QT1NJVElPTkVSfT5cbiAgICAgIHt6SW5kZXggPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgIHt0YXJnZXQoeyBnZXRSZWY6IHNldFRhcmdldFJlZiwgaXNTaG93biB9KX1cblxuICAgICAgICAgICAgPFRyYW5zaXRpb25cbiAgICAgICAgICAgICAgbm9kZVJlZj17cG9zaXRpb25lclJlZn1cbiAgICAgICAgICAgICAgYXBwZWFyXG4gICAgICAgICAgICAgIGluPXtpc1Nob3dufVxuICAgICAgICAgICAgICB0aW1lb3V0PXthbmltYXRpb25EdXJhdGlvbn1cbiAgICAgICAgICAgICAgb25FbnRlcj17aGFuZGxlRW50ZXJ9XG4gICAgICAgICAgICAgIG9uRW50ZXJlZD17b25PcGVuQ29tcGxldGV9XG4gICAgICAgICAgICAgIG9uRXhpdGVkPXtoYW5kbGVFeGl0ZWR9XG4gICAgICAgICAgICAgIHVubW91bnRPbkV4aXRcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3N0YXRlID0+IChcbiAgICAgICAgICAgICAgICA8UG9ydGFsPlxuICAgICAgICAgICAgICAgICAge2NoaWxkcmVuKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBkaW1lbnNpb25zLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZGltZW5zaW9ucy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgekluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjc3M6IGdldENTUyh7XG4gICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogZGltZW5zaW9ucy50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgbGVmdDogZGltZW5zaW9ucy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIHRvcDogZGltZW5zaW9ucy50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgekluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFJlZixcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvUG9ydGFsPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9UcmFuc2l0aW9uPlxuICAgICAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgIClcbiAgICAgIH19XG4gICAgPC9TdGFjaz5cbiAgKVxufSlcblxuUG9zaXRpb25lci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgcG9zaXRpb24gdGhlIGVsZW1lbnQgdGhhdCBpcyBiZWluZyBwb3NpdGlvbmVkIGlzIG9uLlxuICAgKiBTbWFydCBwb3NpdGlvbmluZyBtaWdodCBvdmVycmlkZSB0aGlzLlxuICAgKi9cbiAgcG9zaXRpb246IFByb3BUeXBlcy5vbmVPZihbXG4gICAgUG9zaXRpb24uVE9QLFxuICAgIFBvc2l0aW9uLlRPUF9MRUZULFxuICAgIFBvc2l0aW9uLlRPUF9SSUdIVCxcbiAgICBQb3NpdGlvbi5CT1RUT00sXG4gICAgUG9zaXRpb24uQk9UVE9NX0xFRlQsXG4gICAgUG9zaXRpb24uQk9UVE9NX1JJR0hULFxuICAgIFBvc2l0aW9uLkxFRlQsXG4gICAgUG9zaXRpb24uUklHSFRcbiAgXSksXG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgc2hvdyB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICAgKi9cbiAgaXNTaG93bjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGZyb20gdGhlIGJvZHkgdG8gdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIGJvZHlPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGZyb20gdGhlIHRhcmdldCB0byB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICAgKi9cbiAgdGFyZ2V0T2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gYSBub2RlIGZvciB0aGUgdGFyZ2V0LlxuICAgKiAoeyBnZXRSZWY6ICgpIC0+IFJlZiwgaXNTaG93bjogQm9vbCB9KSAtPiBSZWFjdCBOb2RlXG4gICAqL1xuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEluaXRpYWwgc2NhbGUgb2YgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIGluaXRpYWxTY2FsZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV4aXQgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICovXG4gIG9uQ2xvc2VDb21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZW50ZXIgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICovXG4gIG9uT3BlbkNvbXBsZXRlOiBQcm9wVHlwZXMuZnVuY1xufVxuXG5leHBvcnQgZGVmYXVsdCBQb3NpdGlvbmVyXG4iXX0=