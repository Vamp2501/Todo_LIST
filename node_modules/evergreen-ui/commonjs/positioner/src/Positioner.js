"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactTransitionGroup = require("react-transition-group");

var _constants = require("../../constants");

var _hooks = require("../../hooks");

var _portal = require("../../portal");

var _stack = require("../../stack");

var _getPosition2 = _interopRequireDefault(require("./getPosition"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var animationEasing = {
  spring: 'cubic-bezier(0.175, 0.885, 0.320, 1.175)'
};

var getCSS = function getCSS(_ref) {
  var animationDuration = _ref.animationDuration,
      initialScale = _ref.initialScale;
  return {
    position: 'fixed',
    opacity: 0,
    transitionTimingFunction: animationEasing.spring,
    transitionDuration: "".concat(animationDuration, "ms"),
    transitionProperty: 'opacity, transform',
    transform: "scale(".concat(initialScale, ") translateY(-1px)"),
    '&[data-state="entering"], &[data-state="entered"]': {
      opacity: 1,
      visibility: 'visible',
      transform: 'scale(1)'
    },
    '&[data-state="exiting"]': {
      opacity: 0,
      transform: 'scale(1)'
    }
  };
};

var noop = function noop() {};

var initialDimensions = {
  left: 0,
  top: 0,
  height: 0,
  width: 0,
  transformOrigin: null
};
var Positioner = /*#__PURE__*/(0, _react.memo)(function Positioner(props) {
  var target = props.target,
      isShown = props.isShown,
      children = props.children,
      _props$initialScale = props.initialScale,
      initialScale = _props$initialScale === void 0 ? 0.9 : _props$initialScale,
      _props$animationDurat = props.animationDuration,
      animationDuration = _props$animationDurat === void 0 ? 300 : _props$animationDurat,
      _props$position = props.position,
      position = _props$position === void 0 ? _constants.Position.BOTTOM : _props$position,
      _props$bodyOffset = props.bodyOffset,
      bodyOffset = _props$bodyOffset === void 0 ? 6 : _props$bodyOffset,
      _props$targetOffset = props.targetOffset,
      targetOffset = _props$targetOffset === void 0 ? 6 : _props$targetOffset,
      _props$onOpenComplete = props.onOpenComplete,
      onOpenComplete = _props$onOpenComplete === void 0 ? noop : _props$onOpenComplete,
      _props$onCloseComplet = props.onCloseComplete,
      onCloseComplete = _props$onCloseComplet === void 0 ? noop : _props$onCloseComplet;

  var _useState = (0, _react.useState)(initialDimensions),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      dimensions = _useState2[0],
      setDimensions = _useState2[1];

  var previousDimensions = (0, _hooks.usePrevious)(dimensions, initialDimensions);
  var latestAnimationFrame = (0, _react.useRef)();
  var transitionState = (0, _react.useRef)();
  var positionerRef = (0, _react.useRef)();
  var targetRef = (0, _react.useRef)();
  var setTargetRef = (0, _hooks.useMergedRef)(targetRef);
  var getRef = (0, _hooks.useMergedRef)(positionerRef);
  var update = (0, _react.useCallback)(function () {
    var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!isShown || !targetRef.current || !positionerRef.current) return;
    var targetRect = targetRef.current.getBoundingClientRect();
    var hasEntered = positionerRef.current.getAttribute('data-state') === 'entered';
    var viewportHeight = document.documentElement.clientHeight;
    var viewportWidth = document.documentElement.clientWidth;
    var height;
    var width;

    if (hasEntered) {
      // Only when the animation is done should we opt-in to `getBoundingClientRect`
      var positionerRect = positionerRef.current.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255
      // We need to ceil the width and height to prevent jitter when
      // the window is zoomed (when `window.devicePixelRatio` is not an integer)

      height = Math.round(positionerRect.height);
      width = Math.round(positionerRect.width);
    } else {
      // When the animation is in flight use `offsetWidth/Height` which
      // does not calculate the `transform` property as part of its result.
      // There is still change on jitter during the animation (although unoticable)
      // When the browser is zoomed in â€” we fix this with `Math.max`.
      height = Math.max(positionerRef.current.offsetHeight, prevHeight);
      width = Math.max(positionerRef.current.offsetWidth, prevWidth);
    }

    var _getPosition = (0, _getPosition2["default"])({
      position: position,
      targetRect: targetRect,
      targetOffset: targetOffset,
      dimensions: {
        height: height,
        width: width
      },
      viewport: {
        width: viewportWidth,
        height: viewportHeight
      },
      viewportOffset: bodyOffset
    }),
        rect = _getPosition.rect,
        transformOrigin = _getPosition.transformOrigin;

    setDimensions({
      left: rect.left,
      top: rect.top,
      height: height,
      width: width,
      transformOrigin: transformOrigin
    });
  }, [bodyOffset, isShown, position, targetOffset]); // Call `update` whenever the component has "entered" and dimensions change

  (0, _react.useEffect)(function () {
    if (transitionState.current === 'entered') {
      latestAnimationFrame.current = requestAnimationFrame(function () {
        update(previousDimensions.height, previousDimensions.width);
      });
    }

    return function () {
      if (latestAnimationFrame.current) {
        cancelAnimationFrame(latestAnimationFrame.current);
      }
    };
  }, [previousDimensions.height, previousDimensions.width, update]);

  var handleEnter = function handleEnter() {
    transitionState.current = 'entered';
    update();
  };

  var handleExited = function handleExited() {
    transitionState.current = 'exited';
    setDimensions(initialDimensions);
    onCloseComplete();
  };

  return /*#__PURE__*/_react["default"].createElement(_stack.Stack, {
    value: _constants.StackingOrder.POSITIONER
  }, function (zIndex) {
    return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, target({
      getRef: setTargetRef,
      isShown: isShown
    }), /*#__PURE__*/_react["default"].createElement(_reactTransitionGroup.Transition, {
      nodeRef: positionerRef,
      appear: true,
      "in": isShown,
      timeout: animationDuration,
      onEnter: handleEnter,
      onEntered: onOpenComplete,
      onExited: handleExited,
      unmountOnExit: true
    }, function (state) {
      return /*#__PURE__*/_react["default"].createElement(_portal.Portal, null, children({
        top: dimensions.top,
        left: dimensions.left,
        state: state,
        zIndex: zIndex,
        css: getCSS({
          initialScale: initialScale,
          animationDuration: animationDuration
        }),
        style: {
          transformOrigin: dimensions.transformOrigin,
          left: dimensions.left,
          top: dimensions.top,
          zIndex: zIndex
        },
        getRef: getRef,
        animationDuration: animationDuration
      }));
    }));
  });
});
Positioner.propTypes = {
  /**
   * The position the element that is being positioned is on.
   * Smart positioning might override this.
   */
  position: _propTypes["default"].oneOf([_constants.Position.TOP, _constants.Position.TOP_LEFT, _constants.Position.TOP_RIGHT, _constants.Position.BOTTOM, _constants.Position.BOTTOM_LEFT, _constants.Position.BOTTOM_RIGHT, _constants.Position.LEFT, _constants.Position.RIGHT]),

  /**
   * When true, show the element being positioned.
   */
  isShown: _propTypes["default"].bool,

  /**
   * Function that returns the element being positioned.
   */
  children: _propTypes["default"].func.isRequired,

  /**
   * The minimum distance from the body to the element being positioned.
   */
  bodyOffset: _propTypes["default"].number,

  /**
   * The minimum distance from the target to the element being positioned.
   */
  targetOffset: _propTypes["default"].number,

  /**
   * Function that should return a node for the target.
   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node
   */
  target: _propTypes["default"].func.isRequired,

  /**
   * Initial scale of the element being positioned.
   */
  initialScale: _propTypes["default"].number,

  /**
   * Duration of the animation.
   */
  animationDuration: _propTypes["default"].number,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: _propTypes["default"].func,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: _propTypes["default"].func
};
var _default = Positioner;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9Qb3NpdGlvbmVyLmpzIl0sIm5hbWVzIjpbImFuaW1hdGlvbkVhc2luZyIsInNwcmluZyIsImdldENTUyIsImFuaW1hdGlvbkR1cmF0aW9uIiwiaW5pdGlhbFNjYWxlIiwicG9zaXRpb24iLCJvcGFjaXR5IiwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNmb3JtIiwidmlzaWJpbGl0eSIsIm5vb3AiLCJpbml0aWFsRGltZW5zaW9ucyIsImxlZnQiLCJ0b3AiLCJoZWlnaHQiLCJ3aWR0aCIsInRyYW5zZm9ybU9yaWdpbiIsIlBvc2l0aW9uZXIiLCJwcm9wcyIsInRhcmdldCIsImlzU2hvd24iLCJjaGlsZHJlbiIsIlBvc2l0aW9uIiwiQk9UVE9NIiwiYm9keU9mZnNldCIsInRhcmdldE9mZnNldCIsIm9uT3BlbkNvbXBsZXRlIiwib25DbG9zZUNvbXBsZXRlIiwiZGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJwcmV2aW91c0RpbWVuc2lvbnMiLCJsYXRlc3RBbmltYXRpb25GcmFtZSIsInRyYW5zaXRpb25TdGF0ZSIsInBvc2l0aW9uZXJSZWYiLCJ0YXJnZXRSZWYiLCJzZXRUYXJnZXRSZWYiLCJnZXRSZWYiLCJ1cGRhdGUiLCJwcmV2SGVpZ2h0IiwicHJldldpZHRoIiwiY3VycmVudCIsInRhcmdldFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoYXNFbnRlcmVkIiwiZ2V0QXR0cmlidXRlIiwidmlld3BvcnRIZWlnaHQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsInZpZXdwb3J0V2lkdGgiLCJjbGllbnRXaWR0aCIsInBvc2l0aW9uZXJSZWN0IiwiTWF0aCIsInJvdW5kIiwibWF4Iiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJ2aWV3cG9ydCIsInZpZXdwb3J0T2Zmc2V0IiwicmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlRW50ZXIiLCJoYW5kbGVFeGl0ZWQiLCJTdGFja2luZ09yZGVyIiwiUE9TSVRJT05FUiIsInpJbmRleCIsInN0YXRlIiwiY3NzIiwic3R5bGUiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJvbmVPZiIsIlRPUCIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fUklHSFQiLCJMRUZUIiwiUklHSFQiLCJib29sIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJudW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsZUFBZSxHQUFHO0FBQ3RCQyxFQUFBQSxNQUFNLEVBQUU7QUFEYyxDQUF4Qjs7QUFJQSxJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBUztBQUFBLE1BQUdDLGlCQUFILFFBQUdBLGlCQUFIO0FBQUEsTUFBc0JDLFlBQXRCLFFBQXNCQSxZQUF0QjtBQUFBLFNBQTBDO0FBQ3ZEQyxJQUFBQSxRQUFRLEVBQUUsT0FENkM7QUFFdkRDLElBQUFBLE9BQU8sRUFBRSxDQUY4QztBQUd2REMsSUFBQUEsd0JBQXdCLEVBQUVQLGVBQWUsQ0FBQ0MsTUFIYTtBQUl2RE8sSUFBQUEsa0JBQWtCLFlBQUtMLGlCQUFMLE9BSnFDO0FBS3ZETSxJQUFBQSxrQkFBa0IsRUFBRSxvQkFMbUM7QUFNdkRDLElBQUFBLFNBQVMsa0JBQVdOLFlBQVgsdUJBTjhDO0FBT3ZELHlEQUFxRDtBQUNuREUsTUFBQUEsT0FBTyxFQUFFLENBRDBDO0FBRW5ESyxNQUFBQSxVQUFVLEVBQUUsU0FGdUM7QUFHbkRELE1BQUFBLFNBQVMsRUFBRTtBQUh3QyxLQVBFO0FBWXZELCtCQUEyQjtBQUN6QkosTUFBQUEsT0FBTyxFQUFFLENBRGdCO0FBRXpCSSxNQUFBQSxT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QjtBQUNyQjtBQUNGO0FBQ0E7QUFDQTtBQUNFbkUsRUFBQUEsUUFBUSxFQUFFb0Usc0JBQVVDLEtBQVYsQ0FBZ0IsQ0FDeEJsRCxvQkFBU21ELEdBRGUsRUFFeEJuRCxvQkFBU29ELFFBRmUsRUFHeEJwRCxvQkFBU3FELFNBSGUsRUFJeEJyRCxvQkFBU0MsTUFKZSxFQUt4QkQsb0JBQVNzRCxXQUxlLEVBTXhCdEQsb0JBQVN1RCxZQU5lLEVBT3hCdkQsb0JBQVN3RCxJQVBlLEVBUXhCeEQsb0JBQVN5RCxLQVJlLENBQWhCLENBTFc7O0FBZ0JyQjtBQUNGO0FBQ0E7QUFDRTNELEVBQUFBLE9BQU8sRUFBRW1ELHNCQUFVUyxJQW5CRTs7QUFxQnJCO0FBQ0Y7QUFDQTtBQUNFM0QsRUFBQUEsUUFBUSxFQUFFa0Qsc0JBQVVVLElBQVYsQ0FBZUMsVUF4Qko7O0FBMEJyQjtBQUNGO0FBQ0E7QUFDRTFELEVBQUFBLFVBQVUsRUFBRStDLHNCQUFVWSxNQTdCRDs7QUErQnJCO0FBQ0Y7QUFDQTtBQUNFMUQsRUFBQUEsWUFBWSxFQUFFOEMsc0JBQVVZLE1BbENIOztBQW9DckI7QUFDRjtBQUNBO0FBQ0E7QUFDRWhFLEVBQUFBLE1BQU0sRUFBRW9ELHNCQUFVVSxJQUFWLENBQWVDLFVBeENGOztBQTBDckI7QUFDRjtBQUNBO0FBQ0VoRixFQUFBQSxZQUFZLEVBQUVxRSxzQkFBVVksTUE3Q0g7O0FBK0NyQjtBQUNGO0FBQ0E7QUFDRWxGLEVBQUFBLGlCQUFpQixFQUFFc0Usc0JBQVVZLE1BbERSOztBQW9EckI7QUFDRjtBQUNBO0FBQ0V4RCxFQUFBQSxlQUFlLEVBQUU0QyxzQkFBVVUsSUF2RE47O0FBeURyQjtBQUNGO0FBQ0E7QUFDRXZELEVBQUFBLGNBQWMsRUFBRTZDLHNCQUFVVTtBQTVETCxDQUF2QjtlQStEZWhFLFUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgbWVtbywgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnXG5pbXBvcnQgeyBTdGFja2luZ09yZGVyLCBQb3NpdGlvbiB9IGZyb20gJy4uLy4uL2NvbnN0YW50cydcbmltcG9ydCB7IHVzZU1lcmdlZFJlZiwgdXNlUHJldmlvdXMgfSBmcm9tICcuLi8uLi9ob29rcydcbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gJy4uLy4uL3BvcnRhbCdcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnLi4vLi4vc3RhY2snXG5pbXBvcnQgZ2V0UG9zaXRpb24gZnJvbSAnLi9nZXRQb3NpdGlvbidcblxuY29uc3QgYW5pbWF0aW9uRWFzaW5nID0ge1xuICBzcHJpbmc6ICdjdWJpYy1iZXppZXIoMC4xNzUsIDAuODg1LCAwLjMyMCwgMS4xNzUpJ1xufVxuXG5jb25zdCBnZXRDU1MgPSAoeyBhbmltYXRpb25EdXJhdGlvbiwgaW5pdGlhbFNjYWxlIH0pID0+ICh7XG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICBvcGFjaXR5OiAwLFxuICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGFuaW1hdGlvbkVhc2luZy5zcHJpbmcsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7YW5pbWF0aW9uRHVyYXRpb259bXNgLFxuICB0cmFuc2l0aW9uUHJvcGVydHk6ICdvcGFjaXR5LCB0cmFuc2Zvcm0nLFxuICB0cmFuc2Zvcm06IGBzY2FsZSgke2luaXRpYWxTY2FsZX0pIHRyYW5zbGF0ZVkoLTFweClgLFxuICAnJltkYXRhLXN0YXRlPVwiZW50ZXJpbmdcIl0sICZbZGF0YS1zdGF0ZT1cImVudGVyZWRcIl0nOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB2aXNpYmlsaXR5OiAndmlzaWJsZScsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gIH0sXG4gICcmW2RhdGEtc3RhdGU9XCJleGl0aW5nXCJdJzoge1xuICAgIG9wYWNpdHk6IDAsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gIH1cbn0pXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuY29uc3QgaW5pdGlhbERpbWVuc2lvbnMgPSB7XG4gIGxlZnQ6IDAsXG4gIHRvcDogMCxcbiAgaGVpZ2h0OiAwLFxuICB3aWR0aDogMCxcbiAgdHJhbnNmb3JtT3JpZ2luOiBudWxsXG59XG5cbmNvbnN0IFBvc2l0aW9uZXIgPSBtZW1vKGZ1bmN0aW9uIFBvc2l0aW9uZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldCxcbiAgICBpc1Nob3duLFxuICAgIGNoaWxkcmVuLFxuICAgIGluaXRpYWxTY2FsZSA9IDAuOSxcbiAgICBhbmltYXRpb25EdXJhdGlvbiA9IDMwMCxcbiAgICBwb3NpdGlvbiA9IFBvc2l0aW9uLkJPVFRPTSxcbiAgICBib2R5T2Zmc2V0ID0gNixcbiAgICB0YXJnZXRPZmZzZXQgPSA2LFxuICAgIG9uT3BlbkNvbXBsZXRlID0gbm9vcCxcbiAgICBvbkNsb3NlQ29tcGxldGUgPSBub29wXG4gIH0gPSBwcm9wc1xuXG4gIGNvbnN0IFtkaW1lbnNpb25zLCBzZXREaW1lbnNpb25zXSA9IHVzZVN0YXRlKGluaXRpYWxEaW1lbnNpb25zKVxuICBjb25zdCBwcmV2aW91c0RpbWVuc2lvbnMgPSB1c2VQcmV2aW91cyhkaW1lbnNpb25zLCBpbml0aWFsRGltZW5zaW9ucylcbiAgY29uc3QgbGF0ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZWYoKVxuICBjb25zdCB0cmFuc2l0aW9uU3RhdGUgPSB1c2VSZWYoKVxuICBjb25zdCBwb3NpdGlvbmVyUmVmID0gdXNlUmVmKClcbiAgY29uc3QgdGFyZ2V0UmVmID0gdXNlUmVmKClcbiAgY29uc3Qgc2V0VGFyZ2V0UmVmID0gdXNlTWVyZ2VkUmVmKHRhcmdldFJlZilcbiAgY29uc3QgZ2V0UmVmID0gdXNlTWVyZ2VkUmVmKHBvc2l0aW9uZXJSZWYpXG5cbiAgY29uc3QgdXBkYXRlID0gdXNlQ2FsbGJhY2soXG4gICAgKHByZXZIZWlnaHQgPSAwLCBwcmV2V2lkdGggPSAwKSA9PiB7XG4gICAgICBpZiAoIWlzU2hvd24gfHwgIXRhcmdldFJlZi5jdXJyZW50IHx8ICFwb3NpdGlvbmVyUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGFyZ2V0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgICAgY29uc3QgaGFzRW50ZXJlZCA9IHBvc2l0aW9uZXJSZWYuY3VycmVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnKSA9PT0gJ2VudGVyZWQnXG5cbiAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuXG4gICAgICBsZXQgaGVpZ2h0XG4gICAgICBsZXQgd2lkdGhcbiAgICAgIGlmIChoYXNFbnRlcmVkKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGRvbmUgc2hvdWxkIHdlIG9wdC1pbiB0byBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YFxuICAgICAgICBjb25zdCBwb3NpdGlvbmVyUmVjdCA9IHBvc2l0aW9uZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWdtZW50aW8vZXZlcmdyZWVuL2lzc3Vlcy8yNTVcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjZWlsIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIHByZXZlbnQgaml0dGVyIHdoZW5cbiAgICAgICAgLy8gdGhlIHdpbmRvdyBpcyB6b29tZWQgKHdoZW4gYHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvYCBpcyBub3QgYW4gaW50ZWdlcilcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChwb3NpdGlvbmVyUmVjdC5oZWlnaHQpXG4gICAgICAgIHdpZHRoID0gTWF0aC5yb3VuZChwb3NpdGlvbmVyUmVjdC53aWR0aClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbiBmbGlnaHQgdXNlIGBvZmZzZXRXaWR0aC9IZWlnaHRgIHdoaWNoXG4gICAgICAgIC8vIGRvZXMgbm90IGNhbGN1bGF0ZSB0aGUgYHRyYW5zZm9ybWAgcHJvcGVydHkgYXMgcGFydCBvZiBpdHMgcmVzdWx0LlxuICAgICAgICAvLyBUaGVyZSBpcyBzdGlsbCBjaGFuZ2Ugb24gaml0dGVyIGR1cmluZyB0aGUgYW5pbWF0aW9uIChhbHRob3VnaCB1bm90aWNhYmxlKVxuICAgICAgICAvLyBXaGVuIHRoZSBicm93c2VyIGlzIHpvb21lZCBpbiDigJQgd2UgZml4IHRoaXMgd2l0aCBgTWF0aC5tYXhgLlxuICAgICAgICBoZWlnaHQgPSBNYXRoLm1heChwb3NpdGlvbmVyUmVmLmN1cnJlbnQub2Zmc2V0SGVpZ2h0LCBwcmV2SGVpZ2h0KVxuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHBvc2l0aW9uZXJSZWYuY3VycmVudC5vZmZzZXRXaWR0aCwgcHJldldpZHRoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHJlY3QsIHRyYW5zZm9ybU9yaWdpbiB9ID0gZ2V0UG9zaXRpb24oe1xuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgdGFyZ2V0T2Zmc2V0LFxuICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgd2lkdGg6IHZpZXdwb3J0V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWV3cG9ydEhlaWdodFxuICAgICAgICB9LFxuICAgICAgICB2aWV3cG9ydE9mZnNldDogYm9keU9mZnNldFxuICAgICAgfSlcblxuICAgICAgc2V0RGltZW5zaW9ucyh7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luXG4gICAgICB9KVxuICAgIH0sXG4gICAgW2JvZHlPZmZzZXQsIGlzU2hvd24sIHBvc2l0aW9uLCB0YXJnZXRPZmZzZXRdXG4gIClcblxuICAvLyBDYWxsIGB1cGRhdGVgIHdoZW5ldmVyIHRoZSBjb21wb25lbnQgaGFzIFwiZW50ZXJlZFwiIGFuZCBkaW1lbnNpb25zIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0cmFuc2l0aW9uU3RhdGUuY3VycmVudCA9PT0gJ2VudGVyZWQnKSB7XG4gICAgICBsYXRlc3RBbmltYXRpb25GcmFtZS5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdXBkYXRlKHByZXZpb3VzRGltZW5zaW9ucy5oZWlnaHQsIHByZXZpb3VzRGltZW5zaW9ucy53aWR0aClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChsYXRlc3RBbmltYXRpb25GcmFtZS5jdXJyZW50KSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGxhdGVzdEFuaW1hdGlvbkZyYW1lLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbcHJldmlvdXNEaW1lbnNpb25zLmhlaWdodCwgcHJldmlvdXNEaW1lbnNpb25zLndpZHRoLCB1cGRhdGVdKVxuXG4gIGNvbnN0IGhhbmRsZUVudGVyID0gKCkgPT4ge1xuICAgIHRyYW5zaXRpb25TdGF0ZS5jdXJyZW50ID0gJ2VudGVyZWQnXG4gICAgdXBkYXRlKClcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUV4aXRlZCA9ICgpID0+IHtcbiAgICB0cmFuc2l0aW9uU3RhdGUuY3VycmVudCA9ICdleGl0ZWQnXG4gICAgc2V0RGltZW5zaW9ucyhpbml0aWFsRGltZW5zaW9ucylcbiAgICBvbkNsb3NlQ29tcGxldGUoKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgdmFsdWU9e1N0YWNraW5nT3JkZXIuUE9TSVRJT05FUn0+XG4gICAgICB7ekluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgICB7dGFyZ2V0KHsgZ2V0UmVmOiBzZXRUYXJnZXRSZWYsIGlzU2hvd24gfSl9XG5cbiAgICAgICAgICAgIDxUcmFuc2l0aW9uXG4gICAgICAgICAgICAgIG5vZGVSZWY9e3Bvc2l0aW9uZXJSZWZ9XG4gICAgICAgICAgICAgIGFwcGVhclxuICAgICAgICAgICAgICBpbj17aXNTaG93bn1cbiAgICAgICAgICAgICAgdGltZW91dD17YW5pbWF0aW9uRHVyYXRpb259XG4gICAgICAgICAgICAgIG9uRW50ZXI9e2hhbmRsZUVudGVyfVxuICAgICAgICAgICAgICBvbkVudGVyZWQ9e29uT3BlbkNvbXBsZXRlfVxuICAgICAgICAgICAgICBvbkV4aXRlZD17aGFuZGxlRXhpdGVkfVxuICAgICAgICAgICAgICB1bm1vdW50T25FeGl0XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtzdGF0ZSA9PiAoXG4gICAgICAgICAgICAgICAgPFBvcnRhbD5cbiAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbih7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogZGltZW5zaW9ucy50b3AsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGRpbWVuc2lvbnMubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgY3NzOiBnZXRDU1Moe1xuICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IGRpbWVuc2lvbnMudHJhbnNmb3JtT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGRpbWVuc2lvbnMubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3A6IGRpbWVuc2lvbnMudG9wLFxuICAgICAgICAgICAgICAgICAgICAgIHpJbmRleFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRSZWYsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICA8L1BvcnRhbD5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvVHJhbnNpdGlvbj5cbiAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICApXG4gICAgICB9fVxuICAgIDwvU3RhY2s+XG4gIClcbn0pXG5cblBvc2l0aW9uZXIucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIHRoZSBlbGVtZW50IHRoYXQgaXMgYmVpbmcgcG9zaXRpb25lZCBpcyBvbi5cbiAgICogU21hcnQgcG9zaXRpb25pbmcgbWlnaHQgb3ZlcnJpZGUgdGhpcy5cbiAgICovXG4gIHBvc2l0aW9uOiBQcm9wVHlwZXMub25lT2YoW1xuICAgIFBvc2l0aW9uLlRPUCxcbiAgICBQb3NpdGlvbi5UT1BfTEVGVCxcbiAgICBQb3NpdGlvbi5UT1BfUklHSFQsXG4gICAgUG9zaXRpb24uQk9UVE9NLFxuICAgIFBvc2l0aW9uLkJPVFRPTV9MRUZULFxuICAgIFBvc2l0aW9uLkJPVFRPTV9SSUdIVCxcbiAgICBQb3NpdGlvbi5MRUZULFxuICAgIFBvc2l0aW9uLlJJR0hUXG4gIF0pLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIHNob3cgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIGlzU2hvd246IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBkaXN0YW5jZSBmcm9tIHRoZSBib2R5IHRvIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAqL1xuICBib2R5T2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBkaXN0YW5jZSBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIHRhcmdldE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCBzaG91bGQgcmV0dXJuIGEgbm9kZSBmb3IgdGhlIHRhcmdldC5cbiAgICogKHsgZ2V0UmVmOiAoKSAtPiBSZWYsIGlzU2hvd246IEJvb2wgfSkgLT4gUmVhY3QgTm9kZVxuICAgKi9cbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBJbml0aWFsIHNjYWxlIG9mIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAqL1xuICBpbml0aWFsU2NhbGU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICBhbmltYXRpb25EdXJhdGlvbjogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBleGl0IHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAqL1xuICBvbkNsb3NlQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGVudGVyIHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAqL1xuICBvbk9wZW5Db21wbGV0ZTogUHJvcFR5cGVzLmZ1bmNcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9zaXRpb25lclxuIl19